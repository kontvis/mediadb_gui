v1.0
The All Media screen needs to show Title, Type, Genre, and Year.
The All Media screen should be sortable by Title, Type, Genre, or Year. 
The search on the All Media screen should allow the user to search by Title, Type or Genre

v1.1
The user shall be able to upload a csv to add new items to the catalog. 
An upload csv button will appear in the upper right corner of the view_media page.
The csv template that they use will include these columns:
title,media_type,year,notes,author,isbn,publisher,page_count,physical_description,book_genre,artist,album,track_count,audio_format,audio_genre,director,runtime_minutes,rating,video_format,video_genre

Only title and media_type are required.  
When the template is loaded, an id will be generated for each item, and the date_added 
field will be populated with the date of the upload. 

v1.1.2
Mobile enhancements:
Responsive layout: Use Bootstrap grid and container/row/col-* so pages reflow; keep the <meta name="viewport"> (already present).
Responsive table: Wrap tables in <div class="table-responsive"> and hide low-value columns on small screens with classes like d-none d-sm-table-cell for Genre/Year. Provide an alternate stacked card list for xs screens.
Sortable headers (mobile): Keep header taps, but also provide a compact sort UI (small toolbar or select) for very small screens.
Form UX: Use single-column forms, larger touch targets, input types (tel, number, date) and autocomplete attributes; increase button padding (btn-lg or CSS).
File uploads on mobile: Keep the file input but ensure accept=".csv" and large tappable label; test on iOS/Android (they route to files/camera/gallery differently).
Performance: Serve minified CSS, enable gzip, use CDN for Bootstrap (already used), lazy-load heavy assets, and keep HTML payload small.
Accessibility & touch: Ensure 44–48px minimum tappable targets, clear contrast, and large form labels/placeholders for non‑technical users.
Progressive improvements: Optionally add a responsive list view, small-screen CSS tweaks in style.css, and a simple service-worker or caching headers for offline-readiness.

v2.0
new feature set:

### 1. Photo Capture (Client-Side)
- Add a page that allows the user to take a photo of their book, DVD, or CD using their device camera.
- Use HTML5 file input with camera capture.
- The photo should capture the front cover/spine with visible text.

### 2. Intelligent Processing (Server-Side)
Process the uploaded photo using Google Vision API:
- Detect objects to classify as book, DVD (video), or CD (audio).
- Extract text (OCR) from the image.
- Parse the text to identify title, author, year, etc. using heuristics.

The backend should:
- Receive the image via AJAX/Fetch POST as base64.
- Use Google Vision API for object detection and OCR.
- Parse OCR text to extract metadata fields.
- Return a JSON object containing all fields needed to pre-fill the "Add Media" form.

### 3. Autofill the Add Media Form
- When metadata is returned, automatically populate the form fields.
- Allow the user to edit the fields before submitting.
- When submitted, insert into media_item and the appropriate detail table.

### 4. Code Requirements
- Write clean, modular Flask routes.
- Add a new `/scan` route for the UI.
- Add a new `/lookup_barcode` API endpoint that accepts JSON { barcode: "..." }.
- Implement client-side JS for:
  - Starting/stopping the camera
  - Scanning the barcode
  - Sending the barcode to the backend
  - Autofilling the form

### 5. Deliverables
Please generate:
- The Flask route code for `/lookup_barcode`
- The JS code for barcode scanning using ZXing or QuaggaJS
- The HTML template for the scanning UI
- The JS code that autofills the Add Media form
- Any helper functions needed for metadata lookup
- Example responses from each metadata API
- Error handling for unknown or unsupported barcodes

Make sure the code integrates cleanly with my existing Flask app structure.
